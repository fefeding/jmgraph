  <body>
    <canvas id="cvs" width="600" height="600" style="border: dashed 1px red">
      你的浏览器不支持画布元素
    </canvas>
    <script type="text/javascript">
      //获取画布元素
      var cvs = document.getElementById('cvs');
      //获取到元素的上下文环境对象
      var gl = cvs.getContext('webgl');
      
        const width = gl.canvas.width;
        const height = gl.canvas.height;
        gl.viewport(0, 0, width, height)
        // 设置 webgl 视口，将 -1 到 1 映射为 canvas 上的坐标

        const vertexShader = gl.createShader(gl.VERTEX_SHADER) // 创建一个顶点着色器
        gl.shaderSource(vertexShader, `
        attribute vec4 a_position;
        attribute vec4 aColor;
        attribute vec2 aTextCoord;
        varying vec4 vColor;
        varying  vec2 vTextCoord;

        void main() {
            gl_Position = a_position; // 设置顶点位置
            vColor = aColor;
            vTextCoord = aTextCoord;
        }
        `) // 编写顶点着色器代码
        gl.compileShader(vertexShader) // 编译着色器

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER) // 创建一个片元着色器
        // texture2D(uSample, vTextCoord)
        gl.shaderSource(fragmentShader, `
        precision mediump float;
        uniform vec4 u_color;
        uniform sampler2D uSample;
        varying vec4 vColor;
      varying  vec2 vTextCoord;

        void main() {
            gl_FragColor = texture2D(uSample, vTextCoord);
        }
        `) // 编写片元着色器代码
        gl.compileShader(fragmentShader) // 编译着色器

        const program = gl.createProgram() // 创建一个程序
        gl.attachShader(program, vertexShader) // 添加顶点着色器
        gl.attachShader(program, fragmentShader) // 添加片元着色器
        gl.linkProgram(program) // 连接 program 中的着色器

        gl.useProgram(program) // 告诉 webgl 用这个 program 进行渲染

        const colorLocation = gl.getUniformLocation(program, 'u_color') // 获取 u_color 变量位置
        gl.uniform4f(colorLocation, 0.93, 0.2, 0.56, 0.4) // 设置它的值

        const colors = [Math.random(),Math.random(),Math.random(),1];
       const points = [];
       const uvpoints = [];

       const mw=mh=100;
        const center = {
            x: width / 2,
            y: height / 2
        };
        let colorStop = [Math.random(),Math.random(),Math.random(),1];
       for(let r=0; r<=Math.PI*2;r += 0.1) {	
            const cos = Math.cos(r);
            const sin = Math.sin(r);
            const x = (cos * 200) / center.x;
            const y = (sin * 200) / center.y;
			points.push(x, y);
            let ux = (cos + 1)/2;
            //if(ux < 0.5) ux = ux/2;
            
            let uy = (sin + 1) / 2;
            //if(uy < 0.5) uy = uy/2;

            uvpoints.push(ux, uy);
            colors.push(...colorStop);
		}
        points.push(points[0], points[1]);
        uvpoints.push(uvpoints[0], uvpoints[1]);
        colors.push(...colorStop);
/*
        colorStop = [Math.random(),Math.random(),Math.random(),1];
        const lastLen = points.length;
       for(let r=0; r<=Math.PI*2;r += 0.1) {			
			points.push((Math.cos(r) * 200) / center.x, (Math.sin(r) * 200) / center.y);
            colors.push(...colorStop);
		}
        points.push(points[lastLen], points[lastLen+1]);
        colors.push(...colorStop);*/

        
        // 将这个顶点缓冲对象绑定到 gl.ARRAY_BUFFER
        // 后续对 gl.ARRAY_BUFFER 的操作都会映射到这个缓存
        const vertices = new Float32Array(points);
        
        // 将顶点数据加入的刚刚创建的缓存对象

        //先创建一个缓存对象
      var vertexBuffer = gl.createBuffer()
      //说明缓存对象保存的类型
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)
      //写入坐标数据
      gl.bufferData(gl.ARRAY_BUFFER, vertices,  // 三角形的三个顶点
            // 因为会将数据发送到 GPU，为了省去数据解析，这里使用 Float32Array 直接传送数据
            gl.STATIC_DRAW // 表示缓冲区的内容不会经常更改
        )

        //获取到数组中单个元素的字节数
      var FSIZE = vertices.BYTES_PER_ELEMENT

      


        const positionLocation = gl.getAttribLocation(program, 'a_position') 
        // 开启 attribute 变量，使顶点着色器能够访问缓冲区数据
        gl.vertexAttribPointer( // 告诉 OpenGL 如何从 Buffer 中获取数据
            positionLocation, // 顶点属性的索引
            2, // 组成数量，必须是1，2，3或4。我们只提供了 x 和 y
            gl.FLOAT, // 每个元素的数据类型
            false, // 是否归一化到特定的范围，对 FLOAT 类型数据设置无效
            2*FSIZE, // stride 步长 数组中一行长度，0 表示数据是紧密的没有空隙，让OpenGL决定具体步长
            0 // offset 字节偏移量，必须是类型的字节长度的倍数。
        )
        gl.enableVertexAttribArray(positionLocation);

         //先创建一个缓存对象
        var colorBuffer = gl.createBuffer()
        //说明缓存对象保存的类型
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer)
        var colorArr = new Float32Array(colors);
            //写入坐标数据
        gl.bufferData(gl.ARRAY_BUFFER, colorArr,  // 三角形的三个顶点
                // 因为会将数据发送到 GPU，为了省去数据解析，这里使用 Float32Array 直接传送数据
                gl.STATIC_DRAW // 表示缓冲区的内容不会经常更改
            )

        const vColorLocation = gl.getAttribLocation(program, 'aColor') 
        //gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.93, 0.2, 0.56, 1]), gl.STATIC_DRAW)
        //gl.vertexAttribPointer(vColorLocation, 4, gl.FLOAT, false, 0, 0)
        gl.vertexAttribPointer(vColorLocation, 4, gl.FLOAT, false, 4*colorArr.BYTES_PER_ELEMENT, 0)
        gl.enableVertexAttribArray(vColorLocation)

        
        const aTextCoord = gl.getAttribLocation(program, 'aTextCoord');
        const uSample = gl.getUniformLocation(program, 'uSample');

        //先创建一个缓存对象
        var textCoordBuffer = gl.createBuffer()
        //说明缓存对象保存的类型
        gl.bindBuffer(gl.ARRAY_BUFFER, textCoordBuffer);
        var uvArr = new Float32Array(uvpoints);
            //写入坐标数据
        gl.bufferData(gl.ARRAY_BUFFER, uvArr, 
                // 因为会将数据发送到 GPU，为了省去数据解析，这里使用 Float32Array 直接传送数据
                gl.STATIC_DRAW // 表示缓冲区的内容不会经常更改
            )
        gl.vertexAttribPointer(aTextCoord, 2, gl.FLOAT, false, 2*uvArr.BYTES_PER_ELEMENT, 0)
        gl.enableVertexAttribArray(aTextCoord)

        // 纹理
      var img = new Image();
      
      img.onload = function(){
        draw();
      };
      img.src = 'qrcode.jpg';
      
    
      function draw() {
        var texture = gl.createTexture();
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1) // 图像反转Y轴
        gl.activeTexture(gl.TEXTURE0) // 激活纹理单元
        gl.bindTexture(gl.TEXTURE_2D, texture) // 绑定纹理对象
/*
        const level = 0;
  const internalFormat = gl.RGBA;
  const width = 1;
  const height = 1;
  const border = 0;
  const srcFormat = gl.RGBA;
  const srcType = gl.UNSIGNED_BYTE;
  const pixel = new Uint8Array([0, 0, 255, 255]); // opaque blue
  gl.texImage2D(
    gl.TEXTURE_2D,
    level,
    internalFormat,
    width,
    height,
    border,
    srcFormat,
    srcType,
    pixel
  );*/

        gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR) // 放大处理方式
        gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR) // 缩小处理方式
        gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE) // 水平平铺方式
        gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE) // 竖直平铺方式

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img) // 配置纹理图像
        gl.uniform1i(uSample, 0) // 纹理单元传递给着色器

        gl.clearColor(0, 1, 1, 0) // 设置清空颜色缓冲时的颜色值
        gl.clear(gl.COLOR_BUFFER_BIT) // 清空颜色缓冲区，也就是清空画布

        /*gl.drawArrays( // 从数组中绘制图元
            gl.TRIANGLES, // 渲染三角形
            0,  // 从数组中哪个点开始渲染
            3   // 需要用到多少个点，三角形的三个顶点
        );
        gl.drawArrays( // 从数组中绘制图元
            gl.TRIANGLES, // 渲染三角形
            3,  // 从数组中哪个点开始渲染
            3   // 需要用到多少个点，三角形的三个顶点
        );*/
        gl.drawArrays(gl.TRIANGLE_FAN, 0, points.length);
        //gl.drawArrays(gl.LINE_STRIP, 3, 3);
        //gl.drawArrays(gl.LINE_LOOP, 2, 3);
      }
    </script>
  </body>
